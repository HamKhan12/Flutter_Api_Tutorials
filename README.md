Flutter API Integration Tutorial
This project demonstrates two different approaches to handling API data and JSON parsing in Flutter:

Manual Model Creation: Manually writing the model class and fromJson method.

Plugin-Based Model Generation: Using a code generation plugin (like json_serializable or quicktype) to create the model classes automatically.

üì± Examples Included
1. HomeScreen (HomeScreen.dart)
Fetches a list of posts from JSONPlaceholder API and displays them in a list.

API Endpoint: https://jsonplaceholder.typicode.com/posts

Model Used: PostsModel (Assumed to be generated via a plugin, as it uses PostsModel.fromJson(i))

2. ExampleTwo (ExampleTwo.dart)
Fetches a list of photos from JSONPlaceholder API and displays them with thumbnails and titles.

API Endpoint: https://jsonplaceholder.typicode.com/photos

Model Used: Photos (Manually created within the same file)

üß± Model Comparison
Manually Created Model (Photos in ExampleTwo.dart)
This approach involves writing all the boilerplate code yourself. It's great for learning and small projects.

dart
class Photos {
  String title, url;
  int id;

  Photos({required this.title, required this.url, required this.id});
}
// Parsing is done manually in the Future:
// Photos photos = Photos(title: i['title'], url: i['url'], id: i['id']);
Plugin-Generated Model (PostsModel in models/PostsModel.dart)
This approach uses a build runner plugin to generate the fromJson and toJson methods automatically, reducing boilerplate and potential human error. The code for this model is not in the provided snippet, but it would typically use a factory constructor like .fromJson.

Example of what PostsModel might look like (generated):

dart
// This file is generated automatically.
// NOTE: This code is just an example structure.
part of 'PostsModel.g.dart';

@JsonSerializable()
class PostsModel {
  int? userId;
  int? id;
  String? title;
  String? body;

  PostsModel({this.userId, this.id, this.title, this.body});

  // The fromJson and toJson methods are generated by the build_runner command.
  factory PostsModel.fromJson(Map<String, dynamic> json) => _$PostsModelFromJson(json);
  Map<String, dynamic> toJson() => _$PostsModelToJson(this);
}
üöÄ Key Concepts Demonstrated
API Calling: Using the http package to make GET requests.

JSON Parsing: Converting API response data into Dart objects (JSON decoding).

FutureBuilder: A Flutter widget that builds itself based on the latest snapshot of a Future.

State Management: Using setState to manage local state for the UI.

ListViews: Displaying fetched data in a scrollable list using ListView.builder.

Model Classes: Creating Dart classes (models) to structure API response data.

üõ†Ô∏è Packages Used
http: ^1.1.0 (or higher) - A composable, Future-based library for making HTTP requests.
Add it to your pubspec.yaml:

yaml
dependencies:
  http: ^1.1.0
üîß Getting Started
Clone the repository or add these files to your Flutter project.

Add the HTTP package to your pubspec.yaml file and run flutter pub get.

For Plugin-based Models: If you are using json_serializable, ensure you have the necessary dev dependencies and run the build runner to generate the .g.dart files.

yaml
dev_dependencies:
  build_runner: ^2.4.0
  json_serializable: ^6.7.0
Run the build runner:

bash
flutter pub run build_runner build
Run the app: Navigate to either HomeScreen or ExampleTwo to see the different implementations.

üìß Connect with Me
If you have any questions or want to see more of my work, feel free to connect with me or follow me on GitHub!

üòä Follow me on GitHub for more Flutter tutorials and projects: HamKhan12

üìã Conclusion
This project is an excellent resource for beginners to understand the core concepts of networking in Flutter. It shows two practical ways to parse JSON data, helping you decide which method best suits your project's needs.

Use Manual Parsing for simplicity or when learning the fundamentals.

Use Code Generation for larger projects with complex JSON structures to improve code maintainability and reduce errors.
